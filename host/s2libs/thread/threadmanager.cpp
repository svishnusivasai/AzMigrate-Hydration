#include <map>
#include <string>
#include <cassert>
#include <sstream>

#include "runnable.h"
#include "synchronize.h"
#include "svtypes.h"
#include "event.h"
#include "portablehelpers.h"

#include "s2libsthread.h"
#include "threadmanager.h"

ThreadManager* ThreadManager::theThreadManager = NULL;
THREAD_GROUP_MAP ThreadManager::m_ThreadGroup;
THREAD_GROUP_EVENT_MAP ThreadManager::m_EventGroup;
THREAD_TO_GROUP_MAP ThreadManager::m_ThreadToGroup;

Lockable ThreadManager::m_CreateLock;
Lockable ThreadManager::m_StopLock;
Lockable ThreadManager::m_GenId;
Lockable ThreadManager::m_StopThreadLock;


long int ThreadManager::m_iAutoGeneratedGroupId = 0;


typedef std::pair<THREAD_ID,Thread*> THREAD_PAIR;
typedef std::pair<long int,THREAD_MAP*> GROUP_PAIR;
typedef std::pair<long int,Event*> EVENT_PAIR;
typedef std::pair<THREAD_ID,long int> THREAD_TO_GROUP_PAIR;

ThreadManager::ThreadManager()
{

}

ThreadManager::~ThreadManager()
{


}


ThreadManager& ThreadManager::GetInstance()
{
	DebugPrintf(SV_LOG_DEBUG,"ENTERED %s\n",FUNCTION_NAME);


    AutoLock CreateGuard(m_CreateLock);
	if ( NULL == theThreadManager )
	{
		theThreadManager = new ThreadManager;
	}
	DebugPrintf(SV_LOG_DEBUG,"EXITED %s\n",FUNCTION_NAME);

	return *theThreadManager;
	
}

bool ThreadManager::Destroy()
{
    bool bStatus = true;
    if ( NULL != theThreadManager)
    {
        AutoLock CreateGuard(m_CreateLock);
        if ( m_ThreadGroup.size() <= 0 )
        {
            THREAD_GROUP_EVENT_MAP::iterator EventIterator = m_EventGroup.begin();
            while(EventIterator != m_EventGroup.end() )
            {
                delete EventIterator->second;
                EventIterator->second = NULL;
                ++EventIterator;
            }

            if ( NULL != theThreadManager)
            {
                delete theThreadManager;
                theThreadManager = NULL;
            }
        }
        else
        {
            DebugPrintf(SV_LOG_ERROR,"FAILED: Cannot destroy thread manager. Please stop all running threads first.\n");
            bStatus = false;
        }
    }
    return bStatus;
}

long int ThreadManager::AutoGenerateGroupId()
{
    AutoLock GenGroupIdGuard(m_GenId);
    ++m_iAutoGeneratedGroupId;
    return m_iAutoGeneratedGroupId;
}


bool ThreadManager::StartThreadGroup(RUNNABLE_LIST RunnableObjectsList,PTHREAD_INFO pThreadInfo,long int liGroupId)
{
    THREAD_GROUP_MAP::iterator GroupIterator;
    GroupIterator = m_ThreadGroup.find(liGroupId);
    if ( GroupIterator != m_ThreadGroup.end() )
    {
        DebugPrintf(SV_LOG_ERROR,"FAILED: Thread Group %ld already started.Please add new thread to the group with the use of StartThread\n",liGroupId);
        return false;
    }
    else if ( RunnableObjectsList.size() <= 0 )
    {
        DebugPrintf(SV_LOG_ERROR,"FAILED: No Runnable objects in list. Cannot start a thread group with zero items.\n");
        return false;
    }

    const size_t iThreadsToStart = RunnableObjectsList.size();
    int iThreadsStarted = 0;
    Thread* pThreadObject = NULL;
    RUNNABLE_LIST::iterator RunnableObjectsListIter;
	for(RunnableObjectsListIter = RunnableObjectsList.begin();RunnableObjectsListIter != RunnableObjectsList.end();RunnableObjectsListIter++)
	{	
        if ( (pThreadObject = StartThread(*RunnableObjectsListIter,pThreadInfo,liGroupId)) != NULL )
        {
            ++iThreadsStarted;
        }
        else
        {
            break;
        }
    }

    if ( iThreadsToStart == iThreadsStarted )
    {
        DebugPrintf(SV_LOG_DEBUG,"SUCCESS: Thread Group started successfully.\n");
        Event *pStatus = new Event(false,true);
        EVENT_PAIR eventPair(liGroupId,pStatus);
        m_EventGroup.insert(eventPair);

//        Event *pStatus = EventToGroup(liGroupId);

    }
    else
    {
        // PENDING:
        // If any of the threads in the thread group did not start 
        // do we stop all started threads
        // or allow started threads to continue. 
        // Right now let's stop the threads.
        // Need to evaluate this. 
        StopThreadGroup(liGroupId);
        return false;
    }
    return true;
}

bool ThreadManager::IsGroupRunning(const long int& liGroupId)
{
    bool bRunning = false;
    THREAD_GROUP_EVENT_MAP::iterator EventIterator = m_EventGroup.find(liGroupId);
    if ( EventIterator != m_EventGroup.end() )
    {
        bRunning = !EventIterator->second->IsSignalled();
    }
    return bRunning;
}

Event* ThreadManager::EventToGroup(const long int liGroupId)
{
    Event* pReturnEvent = NULL;
    THREAD_GROUP_EVENT_MAP::iterator EventIterator = m_EventGroup.find(GLOBAL_THREAD_GROUP_ID);
    if ( EventIterator != m_EventGroup.end() )
    {
        pReturnEvent = EventIterator->second;
        //EventIterator->first = liGroupId;
    }
    else
    {
        Event *pReturnEvent = new Event(false,true);//&Status;//
        EVENT_PAIR eventPair(liGroupId,pReturnEvent);
        m_EventGroup.insert(eventPair);
    }
    return pReturnEvent;
}


bool ThreadManager::StopThreadGroup(long int liGroupId,const long int PARAM)
{
    AutoLock StopGuard(m_StopLock);
    bool bStatus = false;

        THREAD_GROUP_MAP::iterator GroupIterator;
        THREAD_MAP::iterator ThreadIterator;
        THREAD_MAP* pThreadMap = NULL;
        Thread* pThread = NULL;
        GroupIterator = m_ThreadGroup.find(liGroupId);
        if ( GroupIterator != m_ThreadGroup.end() )
        {                
            pThreadMap = (THREAD_MAP*)GroupIterator->second;
            size_t threadCount = pThreadMap->size();
            unsigned int uiIndex = 0;
            for(ThreadIterator = pThreadMap->begin();ThreadIterator != pThreadMap->end();ThreadIterator++)
            {
                pThread = (Thread*)ThreadIterator->second;
                pThread->m_bWaitForExit = false;
                pThread->Stop(PARAM);
            }            
            for(ThreadIterator = pThreadMap->begin();ThreadIterator != pThreadMap->end();ThreadIterator++)
            {
                pThread = (Thread*)ThreadIterator->second;
                pThread->m_bWaitForExit = true;
                if ( pThread->WaitForThread() )
                {
                    ++uiIndex;
                }
            }
            if ( uiIndex == pThreadMap->size())
                bStatus = true;
            else
                bStatus = false;

            if ( true == bStatus )
            {
                for(ThreadIterator = pThreadMap->begin();ThreadIterator != pThreadMap->end();ThreadIterator++)
                {
                    m_ThreadToGroup.erase(ThreadIterator->second->GetThreadID());
                    delete ThreadIterator->second;
                    ThreadIterator->second = NULL;
                }
                pThreadMap->erase(pThreadMap->begin(),pThreadMap->end());
                delete GroupIterator->second;
				GroupIterator->second = NULL;
                m_ThreadGroup.erase(GroupIterator);
                
                THREAD_GROUP_EVENT_MAP::iterator EventIterator = m_EventGroup.find(liGroupId);
                if ( EventIterator != m_EventGroup.end() )
                {
                    EventIterator->second->Signal(true);
                    EventIterator->second->Wait(1);
//                    EventIterator->first = GLOBAL_THREAD_GROUP_ID;

                    delete EventIterator->second;
                    EventIterator->second = NULL;
                    m_EventGroup.erase(EventIterator);
                }
            }
        }
        else
        {
            DebugPrintf(SV_LOG_ERROR,"FAILED: Group ID %ld not found.\n",liGroupId);
            bStatus = false;
        }
    return bStatus;
}


bool ThreadManager::StopThread(const THREAD_ID uiThreadId,const long int PARAM)
{
    AutoLock StopThreadGuard(m_StopThreadLock);
    bool bStatus = true;

    THREAD_TO_GROUP_MAP::iterator threadToGroupIter;
    THREAD_GROUP_MAP::iterator GroupIterator;
    THREAD_MAP::iterator ThreadIterator;
    THREAD_MAP* pThreadMap = NULL;
    Thread* pThread = NULL;
    threadToGroupIter = m_ThreadToGroup.find(uiThreadId);
    if ( threadToGroupIter != m_ThreadToGroup.end() )
    {
        GroupIterator = m_ThreadGroup.find(threadToGroupIter->second);
        if ( GroupIterator != m_ThreadGroup.end() )
        {
            pThreadMap = (THREAD_MAP*)GroupIterator->second;
            ThreadIterator = pThreadMap->find(uiThreadId);
            if ( ThreadIterator != pThreadMap->end() )
            {
                pThread = (Thread*)ThreadIterator->second;
                std::stringstream sstid;
                sstid << pThread->GetThreadID() ;
                if ( pThread->Stop(PARAM) )
                {
                    DebugPrintf(SV_LOG_DEBUG,"INFO: Thread %s exited cleanly.\n", sstid.str().c_str());
                    bStatus = true;
                    delete ThreadIterator->second;
                    ThreadIterator->second = NULL;
                    pThread = NULL;
                    pThreadMap->erase(ThreadIterator);
                    m_ThreadToGroup.erase(uiThreadId);

                }
                else
                {
                    bStatus = false;
                    DebugPrintf(SV_LOG_ERROR,"INFO: Failed to stop thread %s.\n", sstid.str().c_str());
                }
            }
        }
    }
    return bStatus;
}

bool ThreadManager::StopAllThreads(const long int PARAM)
{
    assert(!"Not Implemented");
    DebugPrintf(SV_LOG_ERROR,"FAILED: not implemented\n");
    return false;
}

Thread* ThreadManager::StartThread(Runnable* pRunnableObject,PTHREAD_INFO pThreadInfo,long int liGroupId)
{
    Thread* pThread = new Thread;
    THREAD_ID uiThreadID = 0;
    if ( NULL != pThread )
    {   
        
        if ( ( uiThreadID = pThread->Start(pRunnableObject,pThreadInfo) ) > 0 )
        {
            std::stringstream msg;
            msg << "INFO: Thread started successfully. "
                << "Thread ID = " << uiThreadID << ". ";
            DebugPrintf(SV_LOG_DEBUG, "%s\n", msg.str().c_str());
            THREAD_TO_GROUP_PAIR pairThreadToGroup(uiThreadID,liGroupId);
            m_ThreadToGroup.insert(pairThreadToGroup);
                THREAD_GROUP_MAP::iterator GroupIterator;
                THREAD_MAP* pThreadMap = NULL;
                GroupIterator = m_ThreadGroup.find(liGroupId);
                if ( GroupIterator != m_ThreadGroup.end() )
                {
                    pThreadMap = (THREAD_MAP*)GroupIterator->second;
                    THREAD_PAIR pairThread(pThread->GetThreadID(),pThread);
                    pThreadMap->insert(pairThread);
                }
                else
                {
                    pThreadMap = new THREAD_MAP;
                    THREAD_PAIR pairThread(pThread->GetThreadID(),pThread);
                    pThreadMap->insert(pairThread);

                    GROUP_PAIR pairGroup(liGroupId,pThreadMap);
                    m_ThreadGroup.insert(pairGroup);
                }
        }
        else
        {
            DebugPrintf(SV_LOG_ERROR,"FAILED: Failed to create runnable thread. @LINE %d in FILE %s.\n",LINE_NO,FILE_NAME);
            delete pThread;
            pThread = NULL;
        }
    }
    else
    {
        DebugPrintf(SV_LOG_ERROR,"FAILED: Failed to create thread object. @LINE %d in FILE %s.\n",LINE_NO,FILE_NAME);
        pThread = NULL;
    }

    return pThread;
}

Thread* ThreadManager::StartThread(THREAD_FUNC,PTHREAD_INFO pThreadInfo,long int liGroupId)
{
    assert(!"Not Implemented");
    DebugPrintf(SV_LOG_ERROR,"FAILED: not implemented\n");
    return NULL;
}

