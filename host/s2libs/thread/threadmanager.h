//#pragma once

#ifndef THREAD_MANAGER__H
#define THREAD_MANAGER__H

#include <map>
#include "synchronize.h"
#include "s2libsthread.h"
#include "runnable.h"
#include "event.h"

typedef std::map <THREAD_ID,Thread*> THREAD_MAP;
typedef std::map <long int,THREAD_MAP*> THREAD_GROUP_MAP;
typedef std::map <long int,Event*> THREAD_GROUP_EVENT_MAP;
typedef std::map <THREAD_ID,long int> THREAD_TO_GROUP_MAP;

const long int GLOBAL_THREAD_GROUP_ID = -999;

class ThreadManager
{
public:
	static ThreadManager& GetInstance();
    static bool Destroy();
    static long int AutoGenerateGroupId();

    Thread* StartThread(Runnable*,PTHREAD_INFO pThreadInfo = NULL,long int iGroupId=-1);
    bool StartThreadGroup(RUNNABLE_LIST,PTHREAD_INFO pThreadInfo,long int iGroupId);

    Thread* StartThread(THREAD_FUNC,PTHREAD_INFO pThreadInfo = NULL,long int iGroupId=-1);
    bool StopThreadGroup(long int,const long int PARAM=0);
    bool StopThread(const THREAD_ID,const long int PARAM=0);
    bool StopAllThreads(const long int PARAM=0);
    bool IsGroupRunning(const long int&);

private:
    ~ThreadManager();
    ThreadManager();
private:
    static long int m_iAutoGeneratedGroupId;
    static  Lockable m_CreateLock;
    static  Lockable m_StopLock;
    static  Lockable m_GenId;
    static  Lockable m_StopThreadLock;

    Event* EventToGroup(const long int);
	//static auto_ptr<ThreadManager> threadMan;
    static ThreadManager* theThreadManager;
    static THREAD_GROUP_MAP m_ThreadGroup;
    static THREAD_GROUP_EVENT_MAP m_EventGroup;
    static THREAD_TO_GROUP_MAP m_ThreadToGroup;
};

#endif

