//                                       
// Copyright (c) 2005 InMage.
// This file contains proprietary and confidential information and
// remains the unpublished property of InMage. Use,
// disclosure, or reproduction is prohibited except as permitted
// by express written license agreement with InMage.
// 
// File       : customdevices.cpp
// 
// Description: 
// 

#ifndef CUSTOMDEVICES_CPP
#define CUSTOMDEVICES_CPP

//                                       
// Copyright (c) 2005 InMage.
// This file contains proprietary and confidential information and
// remains the unpublished property of InMage. Use,
// disclosure, or reproduction is prohibited except as permitted
// by express written license agreement with InMage.
// 
// File       : customdevices.cpp
// 
// Description: implementation of CustomDevices class see customedevices.h
//              for more details
// 

#include <iostream>
#include <fstream>
#include <sstream>
#include <cerrno>
#include <string>
#include <iomanip>
#include <sys/stat.h>
#include <cstdio>
#include <fcntl.h>
#include <vector>

#include <boost/shared_ptr.hpp>
#include <boost/bind.hpp>

#include "configurator2.h"
#include "customdevices.h"

std::string const FILE_HEADER("WARNING: do not edit this file manually. Use customdevice app to add/update/delete entries");

bool CustomDevices::Read()
{    
    std::ifstream customDevicesStream(m_FileName.c_str());
    if (!customDevicesStream.good()) {
        if (ENOENT != errno) {
            std::cout << "ERROR: opening " << m_FileName << " : " << strerror(errno) << '\n';
            return false;
        }
        return true;
    }
    
    CustomDevice customDevice;
    
    char line[256];

    m_MaxNameLen = 0;
    m_MaxSizeLen = 0;

    std::istringstream inStream;

    std::string sizeStr;

    unsigned long long size;

    customDevicesStream.getline(line, sizeof(line));

    if (FILE_HEADER != line) {
        std::cout << "ERROR: " << m_FileName << " not a valid custom devices file\n";
        return false;
    }
    
    while (!customDevicesStream.eof()) {
        customDevicesStream.getline(line, sizeof(line));
        inStream.str(std::string(line));
        inStream.clear();
        
        customDevice.m_Name.clear();
        customDevice.m_Mount.clear();
        sizeStr.clear();
        customDevice.m_Size = 0;
        customDevice.m_Valid = true;
        size = 0;
        
        inStream >> customDevice.m_Name >> sizeStr >> customDevice.m_Mount;
        if (!customDevice.m_Name.empty()) {
            std::stringstream tmp;
            if ((tmp << sizeStr).fail()
                || !(tmp >> size).eof()
                || size > static_cast<unsigned long long>(std::numeric_limits<long long>::max())
                ) {
                // TODO: should report this issue
                // note this should only happen if customdevice app was not used to add a custom device
                // at which point we can't trust the file as being correct
                std::cout << "WARNING: invalid entry found for custom device " << customDevice.m_Name << ": missing or invalid size\n";
                customDevice.m_Valid = false;
            } else {
                customDevice.m_Size = static_cast<unsigned long long>(size); // cast OK as we checked above that it was <= max long long
            }
            
            m_CustomDevices.insert(customDevice);
            if (customDevice.m_Name.length() > m_MaxNameLen) {
                m_MaxNameLen  = customDevice.m_Name.length();
            }

            if (sizeStr.length() > m_MaxSizeLen) {
                m_MaxSizeLen  = sizeStr.length();
            }
        }

    }

    return true;
}

void CustomDevices::Print()
{
    if (m_CustomDevices.empty()) {
        std::cout << "No custom devices found\n";
        return;
    }

    std::string sizeHeading("Size(bytes)");
    std::string deviceHeading("Device Name");
    std::string mountHeading("Mountpoint");
    std::string space("  ");

    unsigned int nameLen = (deviceHeading.length() > m_MaxNameLen ? deviceHeading.length() : m_MaxNameLen);

    unsigned int sizeLen = (sizeHeading.length() > m_MaxSizeLen ? sizeHeading.length() : m_MaxSizeLen);

    std::cout << "\nCustom Devices File: " << m_FileName << "\n\n";
    std::cout << std::setfill(' ') << std::setw(nameLen) << std::left << deviceHeading << space
              << std::setfill(' ') << std::setw(sizeLen) << std::left << sizeHeading << space
              << mountHeading
              << '\n';

    CustomDevices_t::const_iterator it(m_CustomDevices.begin());
    CustomDevices_t::const_iterator endIt(m_CustomDevices.end());

    for (/*empty*/; it != endIt; ++it) {
        if ((*it).m_Valid) {
            std::cout << std::setfill(' ') << std::setw(nameLen) << std::left << (*it).m_Name << space
                      << std::setfill(' ') << std::setw(sizeLen) << std::right << (*it).m_Size << space
                      << (*it).m_Mount
                      << '\n';
        } else {
            std::cout << (*it).m_Name << " invalid entry\n";
        }            
    }

    std::cout << std::endl;
        
}

bool CustomDevices::DeleteCustomDevice(CustomDevice const & customDevice)
{
    CustomDevices_t::const_iterator foundIt(m_CustomDevices.find(customDevice));

    if (m_CustomDevices.end() == foundIt) {
        return true;
    }

    m_CustomDevices.erase(foundIt);


    return Write();
}
    
bool CustomDevices::AddCustomDevice(CustomDevice & customDevice)
{
    if (!ValidateSize(customDevice)) {
        return false;
    }

    CustomDevices_t::const_iterator foundIt(m_CustomDevices.find(customDevice));

    if (m_CustomDevices.end() != foundIt) {
        // need to update the custom device just found
        // since this is a set we need to erase the found one
        // and insert the new one, but make sure to copy any
        // existing info that has not been set in the new one
        if (0 == customDevice.m_Size && 0 != 0 != (*foundIt).m_Size) {
            customDevice.m_Size = (*foundIt).m_Size;
        }

        if (customDevice.m_Mount.empty() && (*foundIt).m_Mount.empty()) {
            customDevice.m_Mount = (*foundIt).m_Mount;
        }

        m_CustomDevices.erase(foundIt);
    }        

    m_CustomDevices.insert(customDevice);    

    return Write();

}

bool CustomDevices::Write() const
{
    std::ofstream customDevicesStream(m_FileName.c_str());
    
    if (!customDevicesStream.good()) {
        std::cout << "ERROR: opening " << m_FileName << " : " << strerror(errno) << '\n';
        return false;
    }

    customDevicesStream << FILE_HEADER << '\n';
    
    CustomDevices_t::const_iterator it(m_CustomDevices.begin());
    CustomDevices_t::const_iterator endIt(m_CustomDevices.end());
    
    for (/*empty*/; it != endIt; ++it) {
        customDevicesStream << (*it).m_Name << ' ' << (*it).m_Size << ' ' << (*it).m_Mount << '\n';
    }
    
    return true;

}

bool CustomDevices::ValidateSize(CustomDevice const & device)
{
    int fd = open(device.m_Name.c_str(), O_RDONLY);

    if (-1 == fd) {
        std::cout << "ERROR: open "
                  << device.m_Name
                  << " failed: "
                  << strerror(errno)
                  << "\nPlease verify the name of the device and that it is accessable and try again\n";
        return false;
    }

    boost::shared_ptr<void> guard(static_cast<void*>(0), boost::bind(close, fd));

    // TODO: currently assumes 512 byte sector size
    // this may cause reads to fail on some devices if
    // that is not the correct sector size
    off_t sectorSize = 512;
    
    std::vector<char> buffer(sectorSize); 

    off_t bytesRead;

    // see if we can read the device
    if (-1 == read(fd, &buffer[0], sectorSize)) {
        std::cout << "ERROR: read "
                  << device.m_Name
                  << " failed: " << strerror(errno)
                  << "\nPlease verify that the is accessable and try again\n";
        return false;
    }

    if (0 == device.m_Size) {
        // at this point if no size given it is ok. 
        return true;
    }
    
    if (-1 == lseek(fd, device.m_Size, SEEK_SET)) {
        std::cout << "ERROR: the entered size "
                  << device.m_Size
                  << " for "
                  << device.m_Name
                  << " seems to be too large. Please verify the size and try again.\n";
            return false;
    }

    // finally one more read at the end to make sure the size is correct 
    bytesRead = read(fd, &buffer[0], sectorSize);
    if (-1 == bytesRead) {
        std::cout << "ERROR: read " << device.m_Name << " failed: " << strerror(errno) << '\n';
        return false;
    }

    if (0 != bytesRead) {
        std::cout << "ERROR: entered size "
                  << device.m_Size
                  << " seems to be smaller then "
                  << device.m_Name
                  << " size. Please verify the size and try again.\n";
        return false;
    }
    
    return true;
}           


#endif // ifndef CUSTOMDEVICES_CPP
