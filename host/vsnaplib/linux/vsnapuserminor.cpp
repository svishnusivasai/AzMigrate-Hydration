// Copyright (c) 2005 InMage
// This file contains proprietary and confidential information and
// remains the unpublished property of InMage. Use, disclosure,
// or reproduction is prohibited except as permitted by express
// written license aggreement with InMage.
//
// File       : VsnapUser.cpp
//
// Description: Vsnap User library definitions.
//
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<iostream>
#include<errno.h>
#include<sstream>

#include "portablehelpers.h"
#include "portablehelpersmajor.h"
#include "portablehelpersminor.h"
#include "globs.h"
#include "DiskBtreeCore.h"
#include "VsnapCommon.h"
#include "VsnapUser.h"
#include "DiskBtreeHelpers.h"
#include "cdputil.h"
#include "cdpsnapshot.h"
#include <ace/ACE.h>
#include <ace/OS.h>
#include <ace/OS_NS_fcntl.h>
#include <ace/OS_NS_unistd.h>
#include <ace/OS_NS_errno.h>
#include <ace/Global_Macros.h>
#include "volumeinfocollector.h"
#include "volumegroupsettings.h"
#include "drvstatus.h"
#include <sys/mount.h>
#include <mntent.h>

#include "logger.h"
#include "VsnapShared.h"
#include "localconfigurator.h"
#include <sys/sysinfo.h>
#include "configwrapper.h"
#include "inmcommand.h"
#include <sys/ioctl.h>
#include "svtypes.h"
#include "inmsafecapis.h"
#include "inmsafeint.h"
#include "inmageex.h"


void UnixVsnapMgr::StartTick(SV_ULONG & StartTime)
{
    struct sysinfo info ;
    SV_UINT  Return = sysinfo(&info) ;
    if (Return == 0)
        StartTime = info.uptime ;
    else
        StartTime = 0 ;
}

void UnixVsnapMgr::EndTick(SV_ULONG StartTime)
{
    SV_ULONG Diff = 0;
    SV_ULONG EndTime = 0;
    std::stringstream ssmsg;

    struct sysinfo info ;
    SV_UINT  Return = sysinfo(&info) ;
    if (Return == 0)
    {
        EndTime = info.uptime ;
        ssmsg << "This operation took " << EndTime - StartTime << " Seconds\n";
    }
    else
    {
        EndTime = 0 ;
        ssmsg << "Could not found the end time of the operation, but is completed.\n";
    }

    VsnapPrint(ssmsg.str().c_str());
}

bool GetdevicefilefromMountpoint(const char* MntPnt,std::string &DeviceFile)
{
    FILE *fp;
    struct mntent *entry = NULL;
    mntent m_Ent;
    char m_Buffer[MAXPATHLEN*4];
    fp = setmntent(SV_PROC_MNTS, "r");

    if (fp == NULL)
    {
        DebugPrintf(SV_LOG_INFO,"Unable to open the /proc/mounts...\n");
        return false ;
    }

    while( (entry = getmntent_r(fp, &m_Ent, m_Buffer, sizeof(m_Buffer))) != NULL )
    {
        if (!IsValidMntEnt(entry))
            continue;

        if (!IsValidDevfile(entry->mnt_fsname))
            continue;

        if(strcmp(entry->mnt_dir ,MntPnt ) == 0 )
        {
            DeviceFile+= entry->mnt_fsname ;
            endmntent(fp);
            return true;
        }

    }

    if ( NULL != fp ){
        endmntent(fp);
    }

    return true ;
}

void UnixVsnapMgr:: process_proc_mounts(std::vector<volinfo> &fslist)
{
    FILE *fp;
    struct mntent *entry = NULL;
    mntent m_Ent;
    char m_Buffer[MAXPATHLEN*4];
    fp = setmntent(SV_PROC_MNTS, "r");

    if (fp == NULL)
    {
        DebugPrintf("Could not able to open %s \n", setmntent);
        return;
    }

    while( (entry = getmntent_r(fp, &m_Ent, m_Buffer, sizeof(m_Buffer))) != NULL )
    {
        volinfo vol;

        if (!IsValidMntEnt(entry))
            continue;

        if (!IsValidDevfile(entry->mnt_fsname))
            continue;

        vol.devname = entry->mnt_fsname;
        vol.mountpoint = entry->mnt_dir;
        vol.fstype = entry->mnt_type;
        vol.devno = GetDevNumber(vol.devname);
        vol.mounted = true;

        fslist.push_back(vol);
    }
    if ( NULL != fp )
    {
        endmntent(fp);
    }

    return ; //False ;
}

bool UnixVsnapMgr::CreateRequiredVsnapDIR()
{
    bool rv = true;
    std::string dir = VSNAP_DEVICE_DIR;
    SVERROR rc = SVMakeSureDirectoryPathExists(dir.c_str());
    if (rc.failed())
    {
        DebugPrintf(SV_LOG_ERROR, "FAILED  SVMakeSureDirectoryPathExists %s :  %s \n",dir.c_str(),rc.toString());
        rv = false;
    }
    return rv;
}


bool UnixVsnapMgr::MountVol(VsnapVirtualVolInfo *VirtualInfo, VsnapMountInfo *MountData, char* SnapshotDrive,bool &FsmountFailed)
{
    SV_ULONG		ByteOffset  = 0, ulLength = 0;
    char*			Buffer = NULL;
    bool			success = true;
    VsnapErrorInfo	*Error = &VirtualInfo->Error;
    size_t			UniqueIdLength;
    int Return_Mknod = 0 ;
    SV_UINT  minornumber = 0 ; 
    SV_UINT  MkdevNumber = 0 ;

    do 
    {

        // VsnapVirtualVolInfo->DeviceName - autogenerated device name from cx like /dev/vs/cx0
        // or autogenerated device name from cdpcli like /dev/vs/clixxx
        // The linvsnap driver maintains /dev/vs/cx0 or /dev/vs/clixxx

        UniqueIdLength = VirtualInfo->DeviceName.size();

        ByteOffset  = 0;
        INM_SAFE_ARITHMETIC(ulLength    = (SV_ULONG) sizeof(SV_USHORT) + (InmSafeInt<size_t>::Type(UniqueIdLength) + 1) + sizeof(VsnapMountInfo), INMAGE_EX(sizeof(SV_USHORT))(UniqueIdLength)(sizeof(VsnapMountInfo)))
        INM_SAFE_ARITHMETIC(ulLength   += InmSafeInt<size_t>::Type(sizeof(SV_UINT)) + sizeof(SV_UINT), INMAGE_EX(ulLength)(sizeof(SV_UINT)))
        Buffer      = (char*) calloc(ulLength , 1);


        if (!Buffer)
        {
            DebugPrintf(SV_LOG_ERROR, "@LINE %d in FILE %s, calloc failed\n", LINE_NO, FILE_NAME);
            return false;
        } 

        // The vsnap devices are created under /dev/vs/
        // Hence we need to be sure the directory exists
        // linvsnap driver creates the /dev/vs/cx0 or /dev/vs/clixxx
        // TODO - avoid creating directory from userspace		

		if (!CreateVsnapDevice(VirtualInfo, MountData, Buffer, ByteOffset, ulLength))
        {
            free(Buffer);
            return false;
        }

        minornumber  = *(SV_UINT *)(Buffer + (ByteOffset + sizeof(VsnapMountInfo)));

        MkdevNumber = *(SV_UINT *)(Buffer + (ByteOffset + sizeof(VsnapMountInfo)) + sizeof(SV_UINT));

        free(Buffer);

        // mknod is done here to /dev/vs/cxx or /dev/vs/clixxx
        DebugPrintf(SV_LOG_DEBUG,"Executing mknod for device %s\n", VirtualInfo->DeviceName.c_str());

        Return_Mknod = mknod(VirtualInfo->DeviceName.c_str(), S_IFBLK|0600,MkdevNumber);

        if(Return_Mknod!=0) {
            if(ACE_OS::last_error()==EEXIST) {
                struct stat statbuf; 
                if (IsValidDevfile(VirtualInfo->DeviceName.c_str())) { 
                    if (0 == stat(VirtualInfo->DeviceName.c_str(), &statbuf)) { 
                        if (!S_ISBLK(statbuf.st_mode)) { 
                            Error->VsnapErrorCode = ACE_OS::last_error();
                            Error->VsnapErrorStatus = VSANP_NOTBLOCKDEVICE_FAILED;
                            return false; 
                        } //Is Blk else Ends here 
                    } else { 
                        Error->VsnapErrorCode = ACE_OS::last_error();
                        Error->VsnapErrorStatus = VSANP_NOTBLOCKDEVICE_FAILED;
                        return false; 
                    } 
                } else { 
                    Error->VsnapErrorCode = ACE_OS::last_error(); 
                    Error->VsnapErrorStatus = VSNAP_MKNOD_FAILED; 
                    return false; 
                } 
            }
        }
        std::stringstream str1;
        str1<<"Vsnap device "<<VirtualInfo->DeviceName<<" created successfully, VsnapId: "<<VirtualInfo->SnapShotId;
        DebugPrintf(SV_LOG_INFO, "%s\n", str1.str().c_str());
        str1.clear ();
        str1.str ("");

        if(VirtualInfo->State != VSNAP_REMOUNT && !PersistVsnap(MountData, VirtualInfo))
        {
            DebugPrintf(SV_LOG_ERROR, "Unable to Persist Vsnap Information for %s\n", VirtualInfo->DeviceName.c_str());
            VsnapVirtualInfoList VirtualList;
            VirtualInfo->State = VSNAP_UNMOUNT;
            VirtualList.push_back(VirtualInfo);
            Unmount(VirtualList, true);
            return false;
        }


        std::string errmsg;
        if(!IsValidMountPoint(SnapshotDrive, errmsg))
        {
            DebugPrintf(SV_LOG_ERROR, "Unable to mount the vsnap on mount point %s. %s\n",SnapshotDrive,errmsg.c_str());
            return true;
        }

        //Bug# 7227
        std::string formattedVolumeName = MountData->VolumeName;
        CDPUtil::trim(formattedVolumeName);
        FormatVolumeName(formattedVolumeName);
        if (IsReportingRealNameToCx())
        {
            GetDeviceNameFromSymLink(formattedVolumeName);
        }

        std::string fsType = getFSType(formattedVolumeName);

        if(!fsType.empty() && VirtualInfo->MountVsnap)
        {
            if(!VirtualInfo->VolumeName.empty())
            {
                // VSNAPFC - Persistence
                // SnapShotDrive - contains the mounpoint for e.g /mnt/vsnap0
                // or "" if not provided

                SVERROR rc = SVMakeSureDirectoryPathExists(SnapshotDrive);
                if (rc.failed())
                {
                    Error->VsnapErrorStatus = L_VSNAP_MOUNT_FAILED;
                    Error->VsnapErrorMessage = "Unable to create ";
                    Error->VsnapErrorMessage += SnapshotDrive;
                    Error->VsnapErrorMessage += "\n";
                    FsmountFailed=true;
                    return true;
                }

                str1<<"Mounting the virtual volume "<<VirtualInfo->VolumeName;
                DebugPrintf(SV_LOG_INFO, "%s\n", str1.str().c_str());
                str1.clear();
                str1.str("");
                std::string fsmount = "/bin/mount  -o  ";
                if (VirtualInfo->AccessMode == VSNAP_READ_ONLY)
                    fsmount += "ro ";
                else
                    fsmount += "rw " ;

                fsmount += "-t ";
                fsmount += fsType;
                fsmount += " " ;
                fsmount += VirtualInfo->DeviceName.c_str();
                //Bug #7348 - mountpoint with spaces
                fsmount += " " ;
                fsmount += "\"";
                fsmount += SnapshotDrive ;
                fsmount += "\"";

                DebugPrintf(SV_LOG_DEBUG,"Executing : %s\n",fsmount.c_str());

                std::ostringstream args;
                args << fsmount;


                //Bug #4044
                // Using InmCommand class to mount the vsnap

                InmCommand mount(args.str());

                InmCommand::statusType status = mount.Run();

                if (status != InmCommand::completed)
                {
                    Error->VsnapErrorStatus=L_VSNAP_MOUNT_FAILED;
                    Error->VsnapErrorCode = ACE_OS::last_error();
                    if(!mount.StdErr().empty())
                    {
                        Error->VsnapErrorMessage = mount.StdErr();
                    }
                    FsmountFailed=true;
                    return true;
                }

                if (mount.ExitCode())
                {
                    Error->VsnapErrorStatus=L_VSNAP_MOUNT_FAILED;
                    Error->VsnapErrorCode = mount.ExitCode();
                    std::ostringstream msg;
                    msg << "Exit Code = " << mount.ExitCode() << std::endl;
                    if(!mount.StdOut().empty())
                    {
                        msg << "Output = " << mount.StdOut() << std::endl;
                    }
                    if(!mount.StdErr().empty())
                    {
                        msg << "Error = " << mount.StdErr() << std::endl;
                    }
                    Error->VsnapErrorMessage = msg.str();
                    FsmountFailed=true;
                    return true;
                }

                str1.clear();
                str1<<"Virtual Volume "<<VirtualInfo->VolumeName<<" mounted successfully, VsnapId: "<<VirtualInfo->SnapShotId;
                DebugPrintf(SV_LOG_INFO, "%s\n", str1.str().c_str());
                str1.clear ();
            }
        }
        else
        {
			if(!VirtualInfo->MountVsnap)
			{
                str1.clear();
                str1 << "Virtual Volume " << VirtualInfo->VolumeName << " will not be mounted as the user requested not to mount volume."; 
                DebugPrintf(SV_LOG_INFO, "%s\n", str1.str().c_str());
			}
            //Bug #7227
            else if(!VirtualInfo->VolumeName.empty())
            {
                FsmountFailed = true;
                str1.clear();
                str1 << "Virtual Volume " << VirtualInfo->VolumeName << " will not be mounted as the protected volume doesn't contain any filesystem."; 
                DebugPrintf(SV_LOG_INFO, "%s\n", str1.str().c_str());
            }
        }

    } while(false);
    return success;
}


bool UnixVsnapMgr::UnmountVirtualVolume(char* SnapshotDrive, const size_t SnapshotDriveLen, VsnapVirtualVolInfo* VirtualInfo, std::string& output, std::string& error,bool bypassdriver)
{
    bool			status = true;
    VsnapErrorInfo		*Error = &VirtualInfo->Error;
    SVERROR sve = SVS_OK;

    do 
    {
        std::string devicefile = VirtualInfo->DeviceName;
        std::string vsnapdevice = devicefile;

        if(!GetDeviceNameFromSymLink(vsnapdevice))
        {
            Error->VsnapErrorCode = ACE_OS::last_error();
            Error->VsnapErrorStatus = VSNAP_VIRTUAL_VOLUME_NOTEXIST;
            Error->VsnapErrorMessage = ". Unable to obtain DeviceName from SymLink for the device ";
            Error->VsnapErrorMessage += vsnapdevice;
            status = false;
            break;
        }

        sve=HideDrive(devicefile.c_str(),"",output,error,false);
        if(sve.failed())
        {
            //bug 4147
            if((error.find("CHK_DIR:") == 0)) 
            {
                Error->VsnapErrorCode = ACE_OS::last_error();
                Error->VsnapErrorStatus = VSNAP_DIR_SAME_AS_PWD;
                Error->VsnapErrorMessage = error.erase(0,9);
            }
            else
            {
                Error->VsnapErrorCode = ACE_OS::last_error();
                Error->VsnapErrorStatus = VSNAP_UNMOUNT_FAILED_FS_PRESENT;
                Error->VsnapErrorMessage = error;
            }
            status = false;
            break;
        }

        //calling delete ioctl to the driver
        inm_strcpy_s(SnapshotDrive, SnapshotDriveLen, devicefile.c_str());
        if(!bypassdriver)
            status = DeleteVsnapDevice(VirtualInfo,devicefile,error);
        VsnapErrorInfo		*Error1 = &VirtualInfo->Error;
        if(status ||((Error1->VsnapErrorStatus == VSNAP_UNMOUNT_FAILED) && (VirtualInfo->NoFail)))
        {
            unlink(devicefile.c_str());
        }		        
    } while (FALSE);
    return status;
}


bool GetdevicefilefromMountpointAndFileSystem(const char* MntPnt,
                                              std::string& DeviceFile,
                                              std::string &filesystem)
{
    FILE *fp;
    struct mntent *entry = NULL;
    mntent m_Ent;
    char m_Buffer[MAXPATHLEN*4];
    fp = setmntent(SV_PROC_MNTS, "r");

    if (fp == NULL)
    {
        DebugPrintf(SV_LOG_INFO,"Unable to open the /proc/mounts...\n");
        return false ;
    }

    while( (entry = getmntent_r(fp, &m_Ent, m_Buffer, sizeof(m_Buffer))) != NULL )
    {
        if (!IsValidMntEnt(entry))
            continue;

        if (!IsValidDevfile(entry->mnt_fsname))
            continue;

        if(strcmp(entry->mnt_dir ,MntPnt ) == 0 )
        {
            DeviceFile+= entry->mnt_fsname ;
            filesystem = entry->mnt_type;
            endmntent(fp);
            return true;
        }

    }

    if ( NULL != fp ){
        endmntent(fp);
    }

    return true ;
}


bool UnixVsnapMgr::NeedToRecreateVsnap(const std::string &vsnapdevice)
{
    bool bdeviceexists = IsFileORVolumeExisting(vsnapdevice);
    return !bdeviceexists;
}



bool UnixVsnapMgr::PerformZpoolDestroyIfReq(const std::string &devicefile, bool bshoulddeletevsnaplogs)
{
    bool bretval = true;
    return bretval;    
}


bool UnixVsnapMgr::RetryZpoolDestroyIfReq(const std::string &device, const std::string &target, bool bshoulddeletevsnaplogs)
{
    bool bretval = true;
    return bretval;    
}


bool UnixVsnapMgr::CloseLinvsnapSyncDev(const std::string &device, int &fd)
{
    bool bretval = true;
    return bretval;    
}


bool UnixVsnapMgr::OpenLinvsnapSyncDev(const std::string &device, int &fd)
{
    bool bretval = true;
    return bretval;    
}

bool UnixVsnapMgr::StatAndMount(const VsnapPersistInfo& remountInfo)
{
    bool bretval = true;
    return bretval; 
}

void UnixVsnapMgr::CleanUpIncompleteVsnap(VsnapVirtualVolInfo* VirtualInfo)
{
    return;
}

bool UnixVsnapMgr::MountVol_Platform_Specific(VsnapVirtualVolInfo *VirtualInfo, int minornumber, sv_dev_t MkdevNumber)
{
 return true;
}

bool UnixVsnapMgr::Unmount_Platform_Specific(const std::string & devicefile)
{
	return true;
}
